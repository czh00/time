<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>時間</title>
    <style>
        /* CSS 樣式保持不變 */
        /* 全局樣式：設定所有元素的盒模型為 border-box */
        *, *::before, *::after {
            box-sizing: border-box;
        }

        /* body 樣式：設定頁面為全屏顯示，內容居中，背景為黑色 */
        body {
            margin: 0;
            overflow: hidden; /* 隱藏超出視窗的內容 */
            display: flex; /* 使用 Flexbox 佈局 */
            flex-direction: column; /* 垂直排列子元素 */
            justify-content: center; /* 垂直居中對齊 */
            align-items: center; /* 水平居中對齊 */
            min-height: 100vh; /* 最小高度為視窗高度 */
            width: 100vw; /* 寬度為視窗寬度 */
            position: relative; /* 相對定位 */
            background-color: black; /* 背景顏色為黑色 */
            perspective: none; /* 禁用 3D 透視 */
            transform-style: flat; /* 禁用 3D 變換樣式 */
        }

        /* dateTimeDisplay 樣式：時間顯示容器的樣式，包括字體、顏色、陰影和定位 */
        #dateTimeDisplay {
            font-family: 'Segoe UI', Arial, sans-serif; /* 字體設定 */
            font-weight: bold; /* 字體加粗 */
            text-align: center; /* 文字居中對齊 */
            padding: 10px; /* 內邊距 */
            text-shadow: 2px 2px 5px rgba(0, 0, 0, 0.5); /* 文字陰影 */
            color: #00FF00; /* 文字顏色為綠色 */
            position: absolute; /* 絕對定位 */
            transition: transform 1s ease-in-out; /* 變換過渡效果 */
            z-index: 1; /* 層級 */
            transform: translate(-50%, -50%); /* 居中定位 */
            left: 50%; /* 左邊距 50% */
            top: 50%; /* 上邊距 50% */
        }

        /* time-text 樣式：顯示時分的主時間文字樣式 */
        .time-text {
            font-size: 26vw; /* 字體大小根據視窗寬度調整 */
            margin-bottom: -6vw; /* 底部外邊距 */
            position: relative; /* 相對定位 */
            display: inline-block; /* 行內塊級元素 */
        }

        /* time-seconds 樣式：顯示秒數的文字樣式 */
        .time-seconds {
            font-size: 6.25vw; /* 字體大小根據視窗寬度調整 */
            position: absolute; /* 絕對定位 */
            top: 8vw; /* 距離頂部 */
            right: -12vw; /* 距離右側 */
        }

        /* gregorian-date-text 樣式：顯示公曆日期的文字樣式 */
        .gregorian-date-text {
            font-size: 9vw; /* 字體大小根據視窗寬度調整 */
            margin-bottom: -3vw; /* 底部外邊距 */
            display: block; /* 塊級元素 */
            white-space: nowrap; /* 不換行 */
        }

        /* 加入農曆和節氣相關的樣式 */
        /* lunar-jieqi-combined-text 樣式：顯示農曆和節氣的文字樣式 */
        .lunar-jieqi-combined-text {
            font-size: 6vw; /* 字體大小根據視窗寬度調整 */
            display: block; /* 塊級元素 */
            white-space: nowrap; /* 不換行 */
            color: #00FF00; /* 文字顏色為綠色 */
        }

        /* noscript-message 樣式：當 JavaScript 被禁用時顯示的提示訊息樣式 */
        .noscript-message {
            font-size: 0.5em; /* 字體大小 */
            color: #FFB3BA; /* 淺紅色 */
            margin-top: 10px; /* 頂部外邊距 */
            display: block; /* 塊級元素 */
        }
    </style>
    <!-- 加入對外部 lunar-javascript 函式庫的引用，用於農曆和節氣計算 -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/lunar-javascript/1.7.0/lunar.min.js"></script>
</head>
<body>
    <!-- 時間、日期、農曆和節氣的顯示容器 -->
    <div id="dateTimeDisplay"></div>

    <!-- 如果瀏覽器不支援 JavaScript，顯示此訊息 -->
    <noscript>
            <div class="noscript-message">
                您的瀏覽器不支援或已禁用 JavaScript。
            </div>
    </noscript>

    <script>
        let lastSecondTensDigit = -1; // 用於追蹤秒數的十位數，以觸發每十秒的隨機移動
        let currentPosition = { x: 0, y: 0 }; // 追蹤時間顯示元素的當前位置

        /**
         * 更新時間、日期、農曆和節氣的顯示。
         * 每十秒會觸發一次隨機移動效果。
         */
        function updateDateTime() {
            const now = new Date(); // 獲取當前日期和時間
            const currentSeconds = now.getSeconds(); // 獲取當前秒數
            const secondTensDigit = Math.floor(currentSeconds / 10); // 計算秒數的十位數

            // 每十秒隨機移動一次
            if (secondTensDigit !== lastSecondTensDigit) {
                moveRandomly(); // 呼叫隨機移動函數
                lastSecondTensDigit = secondTensDigit; // 更新秒數的十位數
            }

            // 格式化時間和公曆日期
            const timeOptions = { hour: '2-digit', minute: '2-digit', second: '2-digit', hour12: false }; // 時間格式選項
            // 將 weekday 設置為 'long' 以便後續替換為「周幾」
            const gregorianDateOptions = { year: 'numeric', month: 'long', day: 'numeric', weekday: 'long' }; // 公曆日期格式選項

            const fullTimeString = now.toLocaleTimeString('zh-Hant', timeOptions); // 格式化完整時間字串
            let gregorianDateString = now.toLocaleDateString('zh-Hant', gregorianDateOptions); // 格式化公曆日期字串

            // 將「星期幾」替換為「周幾」
            gregorianDateString = gregorianDateString.replace('星期', '周');

            const timeParts = fullTimeString.split(':'); // 分割時間字串
            let hoursMinutes = ''; // 時分部分
            let seconds = ''; // 秒數部分
            if (timeParts.length === 3) {
                hoursMinutes = `${timeParts[0]}:${timeParts[1]}`;
                seconds = timeParts[2];
            } else {
                hoursMinutes = fullTimeString;
            }

            let lunarAndJieQiHtml = ''; // 初始化為空字串，用於存放農曆和節氣的 HTML

            // 農曆和節氣邏輯 (僅在 lunar-javascript 函式庫載入成功時執行)
            // 檢查 Lunar 和 Solar 物件是否存在，以確保函式庫已載入
            if (typeof Lunar !== 'undefined' && typeof Solar !== 'undefined') {
                const year = now.getFullYear(); // 當前年份
                const month = now.getMonth() + 1; // 當前月份 (0-11)
                const day = now.getDate(); // 當前日期
                const hour = now.getHours(); // 當前小時
                const minguoYear = year - 1911; // 計算民國年份

                const solar = Solar.fromYmd(year, month, day); // 創建公曆日期物件
                const lunar = solar.getLunar(); // 獲取對應的農曆日期物件

                /**
                 * 根據小時獲取時辰。
                 * @param {number} h - 當前小時 (0-23)。
                 * @returns {string} 對應的時辰字串。
                 */
                function getShiChen(h) {
                    if (h >= 23 || h < 1) return '子';
                    if (h >= 1 && h < 3) return '丑';
                    if (h >= 3 && h < 5) return '寅';
                    if (h >= 5 && h < 7) return '卯';
                    if (h >= 7 && h < 9) return '辰';
                    if (h >= 9 && h < 11) return '巳';
                    if (h >= 11 && h < 13) return '午';
                    if (h >= 13 && h < 15) return '未';
                    if (h >= 15 && h < 17) return '申';
                    if (h >= 17 && h < 19) return '酉';
                    if (h >= 19 && h < 21) return '戌';
                    if (h >= 21 && h < 23) return '亥';
                    return '';
                }

                const shiChen = getShiChen(hour); // 獲取當前時辰
                const lunarDateString = `${minguoYear}${lunar.getYearShengXiao()}年${lunar.getMonthInChinese()}月${lunar.getDayInChinese()}${shiChen}時`; // 組合農曆日期字串

                // 節氣倒數邏輯
                const today = Solar.fromDate(now); // 創建今天的公曆日期物件
                const lunarToday = today.getLunar(); // 獲取今天的農曆日期物件
                let nextJieQi = null; // 下一個節氣名稱
                let nextJieQiDate = null; // 下一個節氣日期
                let minDiff = Infinity; // 最小天數差

                const jieQis = lunarToday.getJieQiTable(); // 獲取節氣表
                for (const [name, dateStr] of Object.entries(jieQis)) {
                    const date = new Date(dateStr + 'T00:00:00'); // 將節氣日期轉換為 Date 物件
                    if (date >= now) { // 如果節氣日期在當前或未來
                        const diff = Math.ceil((date - now) / (1000 * 60 * 60 * 24)); // 計算與當前日期的天數差
                        if (diff < minDiff) {
                            nextJieQi = name;
                            nextJieQiDate = date;
                            minDiff = diff;
                        }
                    }
                }

                let jieQiText = ''; // 節氣文字
                if (nextJieQi && nextJieQiDate) {
                    if (minDiff === 0) { // 如果天數差為 0，表示節氣就是今天
                        jieQiText = `${nextJieQi}`;
                    } else {
                        jieQiText = `再${minDiff}天${nextJieQi}`;
                    }
                }
                // 只有當農曆函式庫載入成功時才生成這部分的 HTML
                lunarAndJieQiHtml = `<div class="lunar-jieqi-combined-text">${lunarDateString} ${jieQiText}</div>`;
            }

            // 更新畫面
            document.getElementById('dateTimeDisplay').innerHTML = `
                <div class="time-text">
                    <span>${hoursMinutes}</span><span class="time-seconds">${seconds}</span>
                </div>
                <div class="gregorian-date-text">${gregorianDateString}</div>
                ${lunarAndJieQiHtml} <!-- 根據 lunarAndJieQiHtml 的內容有條件地包含農曆/節氣 HTML -->
            `;
        }

        /**
         * 使時間顯示元素在螢幕上隨機移動。
         * 移動範圍受限於安全邊距，以確保元素不會移出視窗。
         */
        function moveRandomly() {
            const displayElement = document.getElementById('dateTimeDisplay'); // 獲取時間顯示元素
            const viewportWidth = window.innerWidth; // 獲取視窗寬度
            const viewportHeight = window.innerHeight; // 獲取視窗高度
            const elementRect = displayElement.getBoundingClientRect(); // 獲取元素的大小和位置
            const elementWidth = elementRect.width; // 元素寬度
            const elementHeight = elementRect.height; // 元素高度
            const safeMargin = 20; // 元素距離視窗邊緣的安全邊距
            const smallOffsetRange = 40; // 每次隨機移動的範圍

            let currentX = currentPosition.x; // 當前 X 座標
            let currentY = currentPosition.y; // 當前 Y 座標

            // 計算隨機偏移量
            const offsetX = (Math.random() * 2 - 1) * smallOffsetRange; // X 軸隨機偏移量
            const offsetY = (Math.random() * 2 - 1) * smallOffsetRange; // Y 軸隨機偏移量

            let newTargetX = currentX + offsetX; // 新的目標 X 座標
            let newTargetY = currentY + offsetY; // 新的目標 Y 座標

            // 計算允許的移動範圍，確保元素不會移出視窗
            const minAllowedX = - (viewportWidth / 2) + (elementWidth / 2) + safeMargin;
            const minAllowedY = - (viewportHeight / 2) + (elementHeight / 2) + safeMargin;
            const maxAllowedX = (viewportWidth / 2) - (elementWidth / 2) - safeMargin;
            const maxAllowedY = (viewportHeight / 2) - (elementHeight / 2) - safeMargin;

            // 將新的目標位置限制在允許的範圍內
            newTargetX = Math.max(minAllowedX, Math.min(newTargetX, maxAllowedX));
            newTargetY = Math.max(minAllowedY, Math.min(newTargetY, maxAllowedY));

            // 更新當前位置並應用 CSS 變換
            currentPosition.x = newTargetX;
            currentPosition.y = newTargetY;
            displayElement.style.transform = `translate(calc(-50% + ${newTargetX}px), calc(-65% + ${newTargetY}px))`;
        }

        // 頁面載入後開始更新時間
        window.onload = function () {
            currentPosition = { x: 0, y: 0 }; // 初始化元素位置
            setInterval(updateDateTime, 1000); // 每秒更新一次
            updateDateTime(); // 立即更新一次以避免延遲
        };
    </script>
</body>
</html>
